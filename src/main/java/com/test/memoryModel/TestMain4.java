package com.test.memoryModel;

/**
 * as-if-serial语义：
 * 不管怎么重排序(编译器和处理器为了提高并行度)， (单线程)程序的执行结果不能被改变
 *
 *
 *
 * 重排序对多线程的影响
 *
 * 假设线程a和线程b
 * a执行writer操作
 * b执行reader操作
 * 当b执行操作4时，是否能够看到操作a对共享变量的写入
 * 答案是不一定能看到
 *
 * 由于操作1和2没有数据依赖关系，编译器和处理器可以对两个
 * 操作进行重排序，同时操作3和4也没有数据依赖关系，编译器和处理器也可以对两个
 * 操作进行重排序
 * 此时如果出现重排序
 * 比如当线程a对操作2执行操作并把值写入共享内存，此时操作3执行判断为真，执行操作4
 * 但此时操作1执行但a值还没有写入共享内存中，就会影响操作结果
 *
 *
 * 控制依赖性
 * 操作3和操作4虽然不存在数据依赖性但是存在控制依赖性
 * 当存在控制依赖性时，会影响指令序列执行的并行度
 * 为此处理器会采用猜测执行来克服控制相关性对并行度的影响
 * 以操作3和4为例，理解猜测执行
 * 线程b的处理器可以提前读取并计算a*a，然后把计算结果临时保存到一个名为重排序缓存区的
 * 硬件缓存中，当接下来操作3判断为真时，就把这个写过写入变量i中
 * 这样的话猜测执行其实质是对操作3和4进行了重排序，重排序在这里破坏了多线程程序的语义
 * （语义：指的是我们想通过代码的表达的意思，比如下面的代码，我们想表达，当我们执行写做操时，就会表示操作状态，当我们读的时候，如果
 * 已经被写，就执行操作4，我们在这里表达的语义是吧操作1和2看成了一个整体，一个操作，但是如果多线程就会出现问题）
 *
 *
 * 在单线程中，对存在依赖控制的操作重排序，不会改变执行结果（因为单线程，代码都是按顺序执行的，比如下面的操作当执行写的时候不会执行读）
 *
 */
public class TestMain4 {
    int a = 0;
    boolean flag = false; // 标识a是否被写入

    public void writer(){
        a = 1; // 1
        flag = true; // 2
    }

    public void reader(){
        if (flag){ // 3
            int i = a * a; // 4
        }
    }


}
